---
title: 泡泡糖项目总结
date: 2025-10-11 13:30:33
tags: 关键问题与解决办法
---
# **泡泡糖项目总结**
## **关键问题与解决方法**
在 “消灭泡泡糖” 游戏的开发过程中，面对复杂的业务逻辑与交互场景，我遇到了多个技术难点，通过系统性分析与多方案验证，我逐一攻克了这些难点，最终形成了稳定可靠的解决方案，确保了项目的顺利完成，具体如下：

### **递归查找同色泡泡糖的死循环问题**
问题：在实现 “点击泡泡糖后自动查找所有同色相邻对象” 的核心功能时，最初采用的递归算法存在严重缺陷：当某一泡泡糖的上下左右均存在同色对象时，递归调用会在相邻泡泡糖之间往复遍历（例如 A→B→A→B...），导致栈内存溢出，程序崩溃。这一问题的本质是未对已访问的泡泡糖进行标记，使得同一对象被重复纳入递归流程。
解决：为解决这一问题，我们在 “待消除集合”（clearStars）中增加了存在性判断机制：在lookupByPath()递归方法中，每次查找相邻泡泡糖前，先通过clearStars.existed(star)判断该对象是否已加入集合。若已存在，则直接终止当前分支的递归；若不存在，则将其加入集合后继续递归。这一机制确保每个泡泡糖仅被处理一次，彻底避免了死循环，同时通过StarList类的existed()方法封装判断逻辑，使代码更具可读性与复用性。

### **继承时的构造器引用共享问题**
问题：在设计MovedStar类（用于记录泡泡糖移动前后的位置）时，最初的实现直接将父类Star的Position对象传递给子类构造器，导致严重的数据耦合：当父类修改坐标信息时，子类的原始坐标也会同步变化，进而引发移动逻辑计算错误（如原位置与移动后位置混淆）。这一问题源于 Java 中对象引用的传递特性 —— 父子类共享同一Position对象的内存地址。
解决：为彻底隔离父子类的数据依赖，我们重构了MovedStar的构造器逻辑：在接收原始坐标参数后，不直接传递引用，而是通过new Position(row, col)创建全新的Position对象，再通过super()方法传递给父类。这一 “克隆式” 初始化确保父子类的坐标属性各自独立，即使父类位置发生变化，子类存储的原始位置也不会受到影响，为移动动画的精准执行提供了数据保障。同时，我们在StarsUtil工具类中封装了clone(Star source)方法，统一处理对象克隆逻辑，避免代码冗余。

### **多列泡泡糖移动的顺序与分组问题**
问题：在实现 “多列泡泡糖同时移动” 功能时，最初的遍历逻辑存在顺序混乱问题：当多个列需要同时向下移动时，直接按行遍历会导致某一列的移动结果干扰其他列的计算（例如左侧列的泡泡糖下移后覆盖右侧列的未处理对象）；此外，水平移动时若不区分空列与非空列的处理顺序，会出现 “已移动列被重复计算” 的错误。
解决：针对这一问题，我们设计了 “先排序、后分组” 的双层处理机制：首先，通过StarsUtil.sort(clearStars)对 “待消除集合” 进行冒泡排序，排序规则为 “先按列升序、再按行升序”，确保从左到右、从下到上依次处理每一列的移动逻辑；其次，使用HashMap<Integer, StarList>数据结构，以列号为键、该列待移动泡泡糖为值进行分组，使每列的移动计算相互独立。在垂直移动中，每组内按 “从底部到顶部” 的顺序计算下移步长；在水平移动中，按 “从左到右” 的顺序处理非空列的左移逻辑。这一机制彻底解决了多列移动的干扰问题，确保移动动画的连贯性与数据一致性。

### **运行时配置文件读取失败（文件未找到）问题**
问题：启动时出现 “FileNotFoundException: score.conf (系统找不到指定的文件)” 错误，导致关卡目标分、积分规则等配置无法加载。经追踪发现，问题根源在于配置文件的路径引用方式存在缺陷。
解决：改用类加载器的getResourceAsStream()方法读取配置文件，类加载器的getResourceAsStream()方法会自动搜索 Java 的类路径（包括 JAR 包内部、src目录、classes目录等），无论配置文件是在开发环境的源码目录中，还是打包后位于 JAR 内部，只需传入资源的相对路径（如"score.conf"）即可定位，无需关心物理路径。